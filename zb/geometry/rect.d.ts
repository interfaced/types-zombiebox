import Direction, { Value as DirectionValue } from './direction';
import Point from './point';
import Corner from './corner';
import Axis from './axis';

export default class Rect {
  x0: number;
  x1: number;
  y0: number;
  y1: number;
  constructor(value: Value);
  isEmpty(): boolean;
  setValue(value: Value): void;
  getValue(): Value;
  getBorderByDirection(direction: Direction): number;
  setBorderByDirection(direction: Direction, value: number): void;
  getPointA(): Point;
  getPointB(): Point;
  getPointCenter(): Point;
  getPointByDirections(directions: Direction[]): Point;
  getPointByCorner(corner: Corner): Point;
  getSize(): Point;
  getSizeByAxis(axis: Axis): number;
  getSizeX(): number;
  getSizeY(): number;
  cutInDirection(direction: Direction, value: number): void;
  openInDirection(direction: Direction): void;
  cutLeft(value: number): void;
  cutRight(value: number): void;
  cutUp(value: number): void;
  cutDown(value: number): void;
  moveX(value: number): void;
  moveY(value: number): void;
  moveXY(point: Point): void;
  moveTo(point: Point): void;
  extendEvenly(value: number): void;
  shrinkDelta(): void;
  clone(): Rect;
  isEqual(rectB: Rect): boolean;
  hasPoint(point: Point): boolean;
  getIntersection(b: Rect): Rect;
  isIntersects(b: Rect): boolean;
  isIntersectsGeometric(b: Rect): boolean;
  getOverflowAll(external: Rect): { [key: string]: number };
  getPositiveOverflowAll(external: Rect): { [key: string]: number };
  isOverflowReachedAll(external: Rect): { [key: string]: boolean };
  getOverflowInDirection(external: Rect, direction: Direction): number;
  isOverflowReachedInDirection(external: Rect, direction: Direction): boolean;
  sub(rectB: Rect): Rect[];
  extrapolateWith(rectB: Rect): Rect;
  splitToPoints(step: Point): Point[];
  page(pageSize: Point): Rect;
  scale(pageSize: Point): Rect;
  toString(): string;
  static createByNumbers(x0: number, y0: number, x1: number, y1: number): Rect;
  static createBySize(size: Point, opt_point?: Point): Rect;
  static createByPoints(p0: Point, p1: Point): Rect;
  static createByClientRect(client: ClientRect): Rect;
  static create(value: Value): Rect;
  static createEmptyRect(): Rect;
  static createOneUnitRect(opt_position?: Point): Rect;
  static createInfiniteRect(): Rect;
  static createHorizontalInfiniteRect(y0: number, y1: number): Rect;
  static createVerticalInfiniteRect(x0: number, x1: number): Rect;
}

export type Value = {
  x0: number;
  y0: number;
  x1: number;
  y1: number;
};
